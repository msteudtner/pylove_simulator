![pylove simultor](/pylove.svg)

## What is Pylove?

Pylove is a quantum circuit simulator specifically for noisy circuits acting on stabilizer codes.
The types of circuits it is build to handle consist of rotations generated by logical operators.
Noisy circuits are simulated via statevector simulation, where a mixed state density matrix is
constructed from a mixture of pure states coming from a specified number of shots.

For an $[[n,k,d]]$ stabilizer code, the simulation complexity is exponential in $k$ and poly 
in $(n-k)$. 

The intention in building this simulator was to be able to simulate quantum error mitigation
using low-distance stabilizer codes for fermionic quantum states. 

Pylove makes use of the OpenFermion software package for manipulating Pauli operators and Fermionic operators.

Also included are a number of tools for generating fermionic encodings and encodings fermionic Hamiltonians
into qubit Hamiltonians acting on a stabilizer code. Fermionic operators are mapped to logical operators of 
the code

## Specifying a stabilizer code

Specify a stabilizer group by a list of generators given as OpenFermion `QubitOperator` objects

## Building the circuit

The circuit is assumed to consist of a sequence of rotations
$$U_1 U_2\dots = \exp^{i\theta_1 Q_1}\exp^{i\theta_2 Q_2}\ldots$$
generated by logical operators $\{Q_1,Q_2,\ldots\}$.

Specified by a list of pairs, specifyin the angle and the logical operator
```python
circuit_schedule = [
    angle[0]*logical_op[0],
    angle[1]*logical_op[1],
    ...
]
```

## Pauli noise channels

Pauli noise channels can be simulated, one specifies the Pauli Kraus operators as always as OpenFermion `QubitOperator` objects.

## Syndrome spaces

The simulator is originally intended to be used for studies of quantum error mitigation in the presence of a collection of $\mathbb{Z}_2$ symmetries or more specifically a stabilizer code. The code enables the simulation of postselection onto different subspaces:
* codespace: Only the codespace is kept, this is the cheapest simulation in terms of memory
* full: All syndrome spaces are kept, this is exponentially costly in the rank of the stabilizer group
* custom: One can specify which syndrome spaces to keep by giving the syndrome patters of the desired subspaces

## Simulation

The most important function is `logical_state_simulation` which contains all the relevant functions for simulation.

```python
(state, block_entries, ideal_state, depth, data)  = logical_state_simulation(
            stabilizers,
            n_phys_qubits,
            rounds,
            stat_noise,
            gate_noise,
            phys_circuit,
            logical_operators,
            d_matrix_blocks,
            block_numbers,
            num_processes
            )
```

Let us quickly describe the argumenets and outputs of this function

Args:
* `stabilizers` : The stabilizer generators of the code
* `n_phys_qubits` : The number of physical qubits (the size of the codespace is inferred form this and the stabilziers)
* `rounds` : The number of shots, i.e. the number of noise realizations to average over
* `stat_noise` : Noise model that acts on idle qubits at each time step
* `gate_noise` : Noise model that acts following the gates
* `phys_circuit` : Sequence of rotations generated by logical operators. Must all commute with all the stabilizer generators 
* `logical_operators` : Additional logical operators, which along with the stabilizer generators, uniquely fix the initial state
* `d_matrix_blocks` : `codespace`, `full`, or `custom`
* `block_numbers` : Which syndrome spaces are kept at the end of each shot, used with `d_matrix_blocks=custom`
* `num_processes` : Number of CPUs to use for parallel execution of shots

Returns:
* `state` : A dictionary containing the density matrices for each syndrome space specified
* `block_entries` : The number of shots that ended in each syndrome space
* `ideal_state` : The ideal output of the circuit if no noise had acted
* `depth` : The number of moments in the circuit in which a gate acted on the physical qubits
* `data` : Other information about the execution of subroutines in preparation for the simulation

## tutorials

See the notebook `example_notebook.ipynb` for an example of Pylove in action